'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _findRoot = require('find-root');

var _findRoot2 = _interopRequireDefault(_findRoot);

var _webpackSources = require('webpack-sources');

var _webpackSources2 = _interopRequireDefault(_webpackSources);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ConcatSource = _webpackSources2.default.ConcatSource;
var isProducation = process.env.NODE_ENV === 'production';

function cleanPath(path) {
  return path.split('/node_modules/').join('/~/');
}

// Get closest package definition from path
function getClosestPackage(modulePath) {
  var root;
  var pkg;

  // Catch findRoot or require errors
  try {
    root = (0, _findRoot2.default)(modulePath);
    pkg = require(_path2.default.join(root, 'package.json'));
  } catch (e) {
    return null;
  }

  // If the package.json does not have a name property, try again from
  // one level higher.
  // https://github.com/jsdnxx/find-root/issues/2
  // https://github.com/date-fns/date-fns/issues/264#issuecomment-265128399
  if (!pkg.name) {
    return getClosestPackage(_path2.default.resolve(root, '..'));
  }

  return {
    package: pkg,
    path: root
  };
}

function check(compilation, modulesToCheck) {
  var context = compilation.compiler.context;
  var modules = {};

  function cleanPathRelativeToContext(modulePath) {
    var cleanedPath = cleanPath(modulePath);

    // Make relative to compilation context
    if (cleanedPath.indexOf(context) === 0) {
      cleanedPath = '.' + cleanedPath.replace(context, '');
    }

    return cleanedPath;
  }

  compilation.modules.forEach(function (module) {
    if (!module.resource) {
      return;
    }

    var pkg;
    var packagePath;

    var closestPackage = getClosestPackage(module.resource);

    // Skip module if no closest package is found
    if (!closestPackage) {
      return;
    }

    pkg = closestPackage.package;
    packagePath = closestPackage.path;

    var modulePath = cleanPathRelativeToContext(packagePath);

    var version = pkg.version;

    if (modulesToCheck.indexOf(pkg.name) < 0) {
      return;
    }

    modules[pkg.name] = modules[pkg.name] || [];

    var isSeen = false;

    modules[pkg.name].forEach(function (module) {
      if (module.version === version) {
        isSeen = true;
      }
    });

    if (!isSeen) {
      var entry = { version: version, path: modulePath };

      modules[pkg.name].push(entry);
    }
  });

  var duplicates = {};
  Object.keys(modules).forEach(function (name) {
    if (modules[name].length > 1) {
      duplicates[name] = modules[name];
    }
  });

  return duplicates;
}

function formatMsg(duplicates) {
  var error = 'Duplicate (conflicting) packages loaded, make sure to use only one: ';

  if (Object.keys(duplicates).length) {
    Object.keys(duplicates).forEach(function (key) {
      var instances = duplicates[key];
      instances = instances.map(function (version) {
        var str = version.version + ' ' + version.path;
        return str;
      });
      error += '\\n  <' + key + '> \\n';
      error += '    ' + instances.join('\\n    ') + '\\n';
    });
  }

  return error;
}

var DuplicateChecker = function () {
  function DuplicateChecker(options) {
    _classCallCheck(this, DuplicateChecker);

    this.options = Object.assign({}, options);;
  }

  _createClass(DuplicateChecker, [{
    key: 'apply',
    value: function apply(compiler) {
      var modulesToCheck = this.options.modulesToCheck;
      if (!modulesToCheck || !modulesToCheck.length) {
        return;
      }

      compiler.plugin('compilation', function (compilation) {
        compilation.plugin('optimize-chunk-assets', function (chunks, callback) {
          chunks.forEach(function (chunk) {
            // In webpack2 chunk.initial was removed. Use isInitial()
            try {
              if (!chunk.initial) return;
            } catch (e) {
              if (!chunk.isInitial()) return;
            }

            var duplicates = check(compilation, modulesToCheck);

            if (Object.keys(duplicates).length && !isProducation) {
              var errorMessages = formatMsg(duplicates);
              chunk.files.forEach(function (file) {
                compilation.assets[file] = new ConcatSource(compilation.assets[file], '\n console.error(\'' + errorMessages + '\');');
              });
            }
          });
          callback();
        });
      });
    }
  }]);

  return DuplicateChecker;
}();

exports.default = DuplicateChecker;
module.exports = exports['default'];