'use strict';

var _loaderUtils = require('loader-utils');

var _loaderUtils2 = _interopRequireDefault(_loaderUtils);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _TraverseImport = require('./TraverseImport');

var _TraverseImport2 = _interopRequireDefault(_TraverseImport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * remove universal-env module dependencies
 * convert to constant
 * then use babel-plugin-minify-dead-code-elimination remove the dead code
 *
 * @example
 *
 * ../evn-loader/lib/index?isWeex=true
 *
 * `import { isWeex, isWeb } from 'universal-env'`;
 *
 * after:
 *
 * ```
 * const isWeex = true;
 * const isWeb = false
 * ```
 */

function mergeSourceMap(map, inputMap) {
  if (inputMap) {
    var inputMapConsumer = new _sourceMap2.default.SourceMapConsumer(inputMap);
    var outputMapConsumer = new _sourceMap2.default.SourceMapConsumer(map);

    var mergedGenerator = new _sourceMap2.default.SourceMapGenerator({
      file: inputMapConsumer.file,
      sourceRoot: inputMapConsumer.sourceRoot
    });

    // This assumes the output map always has a single source, since Babel always compiles a
    // single source file to a single output file.
    var source = outputMapConsumer.sources[0];

    inputMapConsumer.eachMapping(function (mapping) {
      var generatedPosition = outputMapConsumer.generatedPositionFor({
        line: mapping.generatedLine,
        column: mapping.generatedColumn,
        source: source
      });
      if (generatedPosition.column != null) {
        mergedGenerator.addMapping({
          source: mapping.source,

          original: mapping.source == null ? null : {
            line: mapping.originalLine,
            column: mapping.originalColumn
          },

          generated: generatedPosition
        });
      }
    });

    var mergedMap = mergedGenerator.toJSON();
    inputMap.mappings = mergedMap.mappings;
    return inputMap;
  } else {
    return map;
  }
}

module.exports = function (inputSource, inputSourceMap) {
  this.cacheable();
  var callback = this.async();

  var loaderOptions = _loaderUtils2.default.parseQuery(this.query);
  var resourcePath = this.resourcePath;
  var sourceMapTarget = _path2.default.basename(resourcePath);

  var options = Object.assign({ name: 'universal-env' }, loaderOptions);

  if (!Array.isArray(options.name)) {
    options.name = [options.name];
  }

  var _traverseImport = (0, _TraverseImport2.default)(options, inputSource, {
    sourceMaps: true,
    sourceMapTarget: sourceMapTarget,
    sourceFileName: resourcePath
  }),
      code = _traverseImport.code,
      map = _traverseImport.map;

  callback(null, code, mergeSourceMap(map, inputSourceMap));
};