'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseImport;

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _babelTraverse = require('babel-traverse');

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babelTypes = require('babel-types');

var types = _interopRequireWildcard(_babelTypes);

var _babelGenerator = require('babel-generator');

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _babelCodeFrame = require('babel-code-frame');

var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* eslint-disable new-cap */

function traverseImport(options, inputSource, sourceMapOption) {
  var specified = void 0; // Collector import specifiers
  var hasPlatformSpecified = false;

  var platformMap = {
    weex: 'isWeex',
    web: 'isWeb',
    node: 'isNode',
    reactnative: 'isReactNative'
  };

  /**
   * generator variable expression
   *
   * @param  {string} name  identifier
   * @param  {boolean} value
   * @return {VariableDeclaration}
   * @example
   *   variableDeclarationMethod('isWeex', true)
   *
   *   const isWeex = true;
   */
  function variableDeclarationMethod(name, value) {
    return types.VariableDeclaration('const', [types.variableDeclarator(types.Identifier(name), types.BooleanLiteral(value))]);
  }

  /**
   * generator object expression
   *
   * @param  {string} platformName specified platform value it true
   * @return {objectExpression}
   * @example
   *   objectExpressionMethod('isWeex')
   *
   *   {
   *     isWeex: true,
   *     isWeb: false
   *   }
   */
  function objectExpressionMethod(platformName) {
    var properties = [];

    Object.keys(platformMap).forEach(function (p) {
      properties.push(types.objectProperty(types.Identifier(platformMap[p]), types.booleanLiteral(p === platformName)));
    });

    return types.objectExpression(properties);
  }

  var ast = void 0;

  try {
    ast = babylon.parse(inputSource, {
      sourceType: 'module',
      plugins: ['*']
    });
  } catch (err) {
    if (err instanceof SyntaxError) {
      err.lineNumber = err.loc.line;
      err.column = err.loc.column + 1;

      // remove trailing "(LINE:COLUMN)" acorn message and add in esprima syntax error message start
      err.message = 'Line ' + err.lineNumber + ': ' + err.message.replace(/ \((\d+):(\d+)\)$/, '') +
      // add codeframe
      '\n\n' + (0, _babelCodeFrame2.default)(inputSource, err.lineNumber, err.column, { highlightCode: true });
    }

    throw err;
  }

  (0, _babelTraverse2.default)(ast, {
    enter: function enter() {
      specified = new Array();

      if (typeof platformMap[options.platform] !== 'undefined') {
        hasPlatformSpecified = true;
      }
    },

    // Support commonjs method `require`
    CallExpression: function CallExpression(path) {
      var node = path.node;


      if (hasPlatformSpecified && node.callee.name === 'require' && node.arguments[0] && -1 !== options.name.indexOf(node.arguments[0].value)) {
        path.replaceWith(objectExpressionMethod(options.platform));
      }
    },
    ImportDeclaration: function ImportDeclaration(path) {
      var node = path.node;


      if (-1 !== options.name.indexOf(node.source.value)) {
        node.specifiers.forEach(function (spec) {
          if (spec.type === 'ImportNamespaceSpecifier') {
            specified.push({
              local: spec.local.name,
              imported: '*'
            });
          } else {
            specified.push({
              local: spec.local.name,
              imported: spec.imported.name
            });
          }
        });

        if (hasPlatformSpecified) {
          specified.forEach(function (specObj) {
            if (specObj.imported === '*') {
              path.insertAfter(types.VariableDeclaration('const', [types.variableDeclarator(types.Identifier(specObj.local), objectExpressionMethod(options.platform))]));
            } else {
              var newNodeInit = specObj.imported === platformMap[options.platform] ? true : false;
              var newNode = variableDeclarationMethod(specObj.imported, newNodeInit);

              path.insertAfter(newNode);

              // Support custom alise import:
              // import { isWeex as iw } from 'universal-env';
              // const isWeex = true;
              // const iw = true;
              if (specObj.imported !== specObj.local) {
                newNode = variableDeclarationMethod(specObj.local, newNodeInit);
                path.insertAfter(newNode);
              }
            }
          });

          path.remove();
        }
      }
    }
  });

  return (0, _babelGenerator2.default)(ast, Object.assign({
    sourceMaps: true,
    sourceFileName: 'inline',
    sourceMapTarget: 'inline'
  }, sourceMapOption), inputSource);
};
module.exports = exports['default'];