'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _component = require('./component');

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AUTOBIND_BLACKLIST = {
  render: 1,
  shouldComponentUpdate: 1,
  componentWillReceiveProps: 1,
  componentWillUpdate: 1,
  componentDidUpdate: 1,
  componentWillMount: 1,
  componentDidMount: 1,
  componentWillUnmount: 1,
  componentDidUnmount: 1
};

function collateMixins(mixins) {
  var keyed = {};

  for (var i = 0; i < mixins.length; i++) {
    var mixin = mixins[i];
    if (mixin.mixins) {
      applyMixins(mixin, collateMixins(mixin.mixins));
    }

    for (var key in mixin) {
      if (mixin.hasOwnProperty(key) && key !== 'mixins') {
        (keyed[key] || (keyed[key] = [])).push(mixin[key]);
      }
    }
  }

  return keyed;
}

function flattenHooks(key, hooks) {
  var hookType = _typeof(hooks[0]);
  if (hookType === 'object') {
    // Merge objects in hooks
    hooks.unshift({});
    return Object.assign.apply(null, hooks);
  } else if (hookType === 'function' && (key === 'getInitialState' || key === 'getDefaultProps' || key === 'getChildContext')) {
    return function () {
      var ret = void 0;
      for (var i = 0; i < hooks.length; i++) {
        var r = hooks[i].apply(this, arguments);
        if (r) {
          if (!ret) ret = {};
          Object.assign(ret, r);
        }
      }
      return ret;
    };
  } else {
    return hooks[0];
  }
}

function applyMixins(proto, mixins) {
  for (var key in mixins) {
    if (mixins.hasOwnProperty(key)) {
      proto[key] = flattenHooks(key, mixins[key].concat(proto[key] || []));
    }
  }
}

function createReactClass(spec) {
  var ReactClass = function (_Component) {
    _inherits(ReactClass, _Component);

    function ReactClass(props, context) {
      _classCallCheck(this, ReactClass);

      var _this = _possibleConstructorReturn(this, (ReactClass.__proto__ || Object.getPrototypeOf(ReactClass)).call(this, props, context));

      for (var methodName in _this) {
        var method = _this[methodName];
        if (typeof method === 'function' && !AUTOBIND_BLACKLIST[methodName]) {
          _this[methodName] = method.bind(_this);
        }
      }

      if (spec.getInitialState) {
        _this.state = spec.getInitialState.call(_this);
      }
      return _this;
    }

    return ReactClass;
  }(_component2.default);

  if (spec.mixins) {
    applyMixins(spec, collateMixins(spec.mixins));
  }

  Object.assign(ReactClass.prototype, spec);

  if (spec.statics) {
    Object.assign(ReactClass, spec.statics);
  }

  if (spec.propTypes) {
    ReactClass.propTypes = spec.propTypes;
  }

  if (spec.getDefaultProps) {
    ReactClass.defaultProps = spec.getDefaultProps();
  }

  if (spec.contextTypes) {
    ReactClass.contextTypes = spec.contextTypes;
  }

  if (spec.childContextTypes) {
    ReactClass.childContextTypes = spec.childContextTypes;
  }

  if (spec.displayName) {
    ReactClass.displayName = spec.displayName;
  }

  return ReactClass;
}

exports.default = createReactClass;
module.exports = exports['default'];