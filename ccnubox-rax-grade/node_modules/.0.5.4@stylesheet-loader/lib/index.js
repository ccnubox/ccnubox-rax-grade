'use strict';

var _css = require('css');

var _css2 = _interopRequireDefault(_css);

var _transformer = require('./transformer');

var _transformer2 = _interopRequireDefault(_transformer);

var _loaderUtils = require('loader-utils');

var _loaderUtils2 = _interopRequireDefault(_loaderUtils);

var _promptMessage = require('./promptMessage');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RULE = 'rule';
var FONT_FACE_RULE = 'font-face';
var MEDIA_RULE = 'media';
var QUOTES_REG = /['|"]/g;

module.exports = function (source) {
  this.cacheable && this.cacheable();

  var stylesheet = _css2.default.parse(source).stylesheet;

  if (stylesheet.parsingErrors.length) {
    throw new Error('StyleSheet Parsing Error occured.');
  }

  var parseData = parse(this.query, stylesheet);

  return genStyleContent(parseData);
};

var parse = function parse(query, stylesheet) {
  var styles = {};
  var fontFaceRules = [];
  var mediaRules = [];
  var parseQuery = _loaderUtils2.default.parseQuery(query);
  var transformDescendantCombinator = parseQuery.transformDescendantCombinator;

  stylesheet.rules.forEach(function (rule) {
    var style = {};

    // normal rule
    if (rule.type === RULE) {
      style = _transformer2.default.convert(rule);

      rule.selectors.forEach(function (selector) {
        var sanitizedSelector = _transformer2.default.sanitizeSelector(selector, transformDescendantCombinator, rule.position);

        if (sanitizedSelector) {
          // handle pseudo class
          var pseudoIndex = sanitizedSelector.indexOf(':');
          if (pseudoIndex > -1) {
            var pseudoStyle = {};
            var pseudoName = selector.slice(pseudoIndex + 1);
            sanitizedSelector = sanitizedSelector.slice(0, pseudoIndex);

            Object.keys(style).forEach(function (prop) {
              pseudoStyle[prop + pseudoName] = style[prop];
            });

            style = pseudoStyle;
          }

          styles[sanitizedSelector] = Object.assign(styles[sanitizedSelector] || {}, style);
        }
      });
    }

    // font face rule
    if (rule.type === FONT_FACE_RULE) {
      var font = {};
      rule.declarations.forEach(function (declaration) {
        font[declaration.property] = declaration.value;
      });
      fontFaceRules.push(font);
    }

    // media rule
    if (rule.type === MEDIA_RULE) {
      mediaRules.push({
        key: rule.media,
        data: parse(query, rule).data
      });
    }
  });

  return {
    styles: styles,
    fontFaceRules: fontFaceRules,
    mediaRules: mediaRules
  };
};

var genStyleContent = function genStyleContent(parseData) {
  var styles = parseData.styles,
      fontFaceRules = parseData.fontFaceRules,
      mediaRules = parseData.mediaRules;

  var fontFaceContent = getFontFaceContent(fontFaceRules);
  var mediaContent = getMediaContent(mediaRules);
  var warnMessageOutput = getWarnMessageOutput();

  (0, _promptMessage.resetMessage)();

  return 'var _styles = ' + stringifyData(styles) + ';\n  ' + fontFaceContent + '\n  ' + mediaContent + '\n  ' + warnMessageOutput + '\n  module.exports = _styles;\n  ';
};

var getWarnMessageOutput = function getWarnMessageOutput() {
  var errorMessages = (0, _promptMessage.getErrorMessages)();
  var warnMessages = (0, _promptMessage.getWarnMessages)();
  var output = '';

  if (errorMessages) {
    output += '\n  if (process.env.NODE_ENV !== \'production\') {\n    console.error(\'' + errorMessages + '\');\n  }\n    ';
  }
  if (warnMessages) {
    output += '\n  if (process.env.NODE_ENV !== \'production\') {\n    console.warn(\'' + warnMessages + '\');\n  }\n    ';
  }

  return output;
};

var getMediaContent = function getMediaContent(mediaRules) {
  var content = '';

  mediaRules.forEach(function (rule, index) {
    content += '\n  if (window.matchMedia && window.matchMedia(\'' + rule.key + '\').matches) {\n    var ruleData = ' + stringifyData(rule.data) + ';\n    for(var key in ruleData) {\n      _styles[key] = Object.assign(_styles[key], ruleData[key]);\n    }\n  }\n    ';
  });

  return content;
};

var getFontFaceContent = function getFontFaceContent(rules) {
  var content = '';

  if (rules.length > 0) {
    content += '\n  if (typeof FontFace === \'function\') {\n    ';
  }

  rules.forEach(function (rule, index) {
    content += '\n    var fontFace' + index + ' = new FontFace(\'' + rule['font-family'].replace(QUOTES_REG, '') + '\', \'' + rule.src.replace(QUOTES_REG, '') + '\');\n    document.fonts.add(fontFace' + index + ');\n    ';
  });

  if (rules.length > 0) {
    content += '\n  }\n    ';
  }
  return content;
};

var stringifyData = function stringifyData(data) {
  return JSON.stringify(data, undefined, '  ');
};